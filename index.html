<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.3/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.14.3"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.3/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{"type":"heading","depth":0,"payload":{"lines":[2,3]},"content":"PERFILADORES","children":[{"type":"heading","depth":1,"payload":{"lines":[4,5]},"content":"Optimización de programas","children":[{"type":"heading","depth":2,"payload":{"lines":[5,6]},"content":"Un algoritmo está optimizado cuando un programa está modificado para","children":[{"type":"heading","depth":3,"payload":{"lines":[6,7]},"content":"Ejecutarse rápidamente"},{"type":"heading","depth":3,"payload":{"lines":[7,8]},"content":"Ser capaz de operar con menos memoria u otros recursos"},{"type":"heading","depth":3,"payload":{"lines":[8,9]},"content":"Consumir menos energía."}]},{"type":"heading","depth":2,"payload":{"lines":[9,10]},"content":"Niveles de optimización","children":[{"type":"heading","depth":3,"payload":{"lines":[10,11]},"content":"Nivel de diseño","children":[{"type":"heading","depth":4,"payload":{"lines":[11,12]},"content":"Afecta a su rendimiento."},{"type":"heading","depth":4,"payload":{"lines":[12,13]},"content":"La elección del algoritmo afecta la eficiencia más que cualquier otro elemento del diseño, la elección del algoritmo suele ser lo primero que hay que decidir"}]},{"type":"heading","depth":3,"payload":{"lines":[13,14]},"content":"Nivel de código fuente","children":[{"type":"heading","depth":4,"payload":{"lines":[14,15]},"content":"Evitar la codificación de mala calidad y codificar bajo buenas practicas, logrando así mejorar el rendimiento, evitando relentizaciones obvias."}]},{"type":"heading","depth":3,"payload":{"lines":[15,16]},"content":"Nivel de compilación","children":[{"type":"heading","depth":4,"payload":{"lines":[16,17]},"content":"Un compilador es un Software que traduce un programa escrito en un lenguaje de programación en un lenguaje de máquina y un compilador generalmente genera lenguaje ensamblador primero y luego traduce el lenguaje ensamblador al lenguaje máquina."},{"type":"heading","depth":4,"payload":{"lines":[17,18]},"content":"Existen compiladores Cruzados, compiladores optimizadores y compiladores JIT egún se necesitan."}]},{"type":"heading","depth":3,"payload":{"lines":[18,19]},"content":"Nivel de ensamblador","children":[{"type":"heading","depth":4,"payload":{"lines":[19,20]},"content":"Ensamblador es un lenguaje de programación de bajo nivel que representa instrucciones básicas para los computadores, microprocesadores, microcontroladores y otros circuitos integrados programables."}]},{"type":"heading","depth":3,"payload":{"lines":[20,21]},"content":"Nivel en el tiempo de ejecución.","children":[{"type":"heading","depth":4,"payload":{"lines":[21,22]},"content":"Los compiladores just-in-time y los programadores de ensamblador son capases de realizar la optimización en tiempo de ejecución excediendo la capacidad de los compiladores estáticos, ajustando dinámicamente los parámetros de acuerdo con la entrada actual u otros factores."}]}]},{"type":"heading","depth":2,"payload":{"lines":[22,23]},"content":"Compilador just-in-time","children":[{"type":"heading","depth":3,"payload":{"lines":[23,24]},"content":"Componente del entorno de ejecución que mejora el rendimiento de aplicaciones compilando códigos de bytes en código de máquina nativo en tiempo de ejecución, la compilación la hace en tiempo de ejecución"}]}]},{"type":"heading","depth":1,"payload":{"lines":[24,25]},"content":"Definición","children":[{"type":"heading","depth":2,"payload":{"lines":[25,26]},"content":"Es un programa que recolecta estadísticas sobre el comportamiento de un programa u objeto durante la ejecución, el número de veces que se llama cada procedimiento y el porcentaje de tiempo de ejecución que se ocupa en cada uno de ellos."},{"type":"heading","depth":2,"payload":{"lines":[26,27]},"content":"Se suelen utilizar profilers para encontrar las secciones del programa que está tomando la mayor cantidad de recursos, el famoso - el cuello de botella"}]},{"type":"heading","depth":1,"payload":{"lines":[28,29]},"content":"Profiling","children":[{"type":"heading","depth":2,"payload":{"lines":[29,30]},"content":"El “profiling” (por su nombre en inglés) o perfilado, comúnmente llamado análisis de rendimiento es toda aquella investigación del comportamiento de algún programa computacional, usando información que es reunida desde el análisis dinámico."},{"type":"heading","depth":2,"payload":{"lines":[30,31]},"content":"Usualmente el Profiling es utilizado durante el desarrollo de software como método para la depuración y optimización de los algoritmos"},{"type":"heading","depth":2,"payload":{"lines":[31,32]},"content":"Se puede llevar a cabo en el código fuente o sobre un binario ejecutable mediante una herramienta llamada profiler."},{"type":"heading","depth":2,"payload":{"lines":[33,34]},"content":"Las herramientas de análisis de rendimiento ya existían en las plataformas IBM S/360 y IBM System/370 de principios de 1970.","children":[{"type":"heading","depth":3,"payload":{"lines":[34,35]},"content":"El IBM S/360 (S/360) fue un sistema de computación de la familia mainframe (computadora utilizada principalmente por grandes organizaciones para aplicaciones críticas,procesamiento de datos masivos; como censos y estadísticas de la industria y del consumido."},{"type":"heading","depth":3,"payload":{"lines":[36,37]},"content":"El IBM System/370 (también conocido como S/370) fue un modelo de los mainframes de IBM anunciado el 30 de junio de 1970 como sucesor de la familia System/360. La serie mantiene la retrocompatibilidad con el S/360, lo que facilita a los clientes la migración, además de mejorar el rendimiento."}]},{"type":"heading","depth":2,"payload":{"lines":[38,39]},"content":"Cobertura de código","children":[{"type":"heading","depth":3,"payload":{"lines":[39,40]},"content":"Mide el grado en que el código fuente de un programa ha sido comprobado con pruebas de software."},{"type":"heading","depth":3,"payload":{"lines":[40,41]},"content":"Determina la calidad del test que se lleve a cabo y para determinar las partes críticas del código que no han sido comprobadas y las partes que ya lo fueron, además se puede utilizar como técnica de optimización dentro de un compilador optimizador para llevar a cabo una eliminación de código muerto, más específicamente sirve para detectar código inalcanzable."},{"type":"heading","depth":3,"payload":{"lines":[41,42]},"content":"Un código inalcanzable es aquel que nunca podrá ser ejecutado porque no existe ningún camino dentro de las estructuras de control en el resto del programa para llegar a ese código"},{"type":"heading","depth":3,"payload":{"lines":[42,43]},"content":"El código inalcanzable generalmente se considera indeseable por las siguiente razones:","children":[{"type":"heading","depth":4,"payload":{"lines":[43,44]},"content":"Genera almacenamiento innecesario en la caché de instrucciones de la CPU - lo que"},{"type":"heading","depth":4,"payload":{"lines":[44,45]},"content":"También disminuye la localidad de datos."}]}]},{"type":"heading","depth":2,"payload":{"lines":[45,46]},"content":"Compilador optimizador","children":[{"type":"heading","depth":3,"payload":{"lines":[46,47]},"content":"Es un compilador que minimiza ciertos atributos de un programa informático con el fin de aumentar la eficiencia y rendimiento."},{"type":"heading","depth":3,"payload":{"lines":[47,48]},"content":"Las optimizaciones del compilador se aplican generalmente mediante una secuencia de transformaciones de optimización, algoritmos que transforman un programa para producir otro con una salida semánticamente equivalente pero optimizado."},{"type":"heading","depth":3,"payload":{"lines":[48,49]},"content":"Se realiza mediante la optimización temporal, espacial, reduce el tamaño del programa y minimiza la potencia consumida por el mismo"}]},{"type":"heading","depth":2,"payload":{"lines":[49,50]},"content":"Fuzzer","children":[{"type":"heading","depth":3,"payload":{"lines":[50,51]},"content":"Es un programa que intenta descubrir vulnerabilidades de seguridad enviando una entrada arbitraria a una aplicación"},{"type":"heading","depth":3,"payload":{"lines":[51,52]},"content":"Si el programa contiene una vulnerabilidad que puede conducir a una excepción, el choque o el error puede ser determinado que una vulnerabilidad ha sido descubierta."}]}]},{"type":"heading","depth":1,"payload":{"lines":[52,53]},"content":"¿Cómo implementar un perfilador?","children":[{"type":"heading","depth":2,"payload":{"lines":[53,54]},"content":"Tipos de arquitectura","children":[{"type":"heading","depth":3,"payload":{"lines":[54,55]},"content":"Monolítica","children":[{"type":"heading","depth":4,"payload":{"lines":[55,56]},"content":"El software se estructura en grupos funcionales muy acoplados. No hay distribución, ni a nivel físico (hardware) ni a nivel lógico (software); por lo que todo se ejecuta en una máquina, generalmente por un único usuario."}]},{"type":"heading","depth":3,"payload":{"lines":[56,57]},"content":"Cliente – servidor","children":[{"type":"heading","depth":4,"payload":{"lines":[57,58]},"content":"Formada por un programa (cliente informático) que realiza peticiones a otro programa (el servidor) para obtener cierta respuesta."},{"type":"heading","depth":4,"payload":{"lines":[58,59]},"content":"Uno de los clientes más utilizados, es el navegador web. Muchos servidores son capaces de ofrecer sus servicios a través de un navegador web en lugar de requerir la instalación de un programa específico"}]},{"type":"heading","depth":3,"payload":{"lines":[59,60]},"content":"En capas","children":[{"type":"heading","depth":4,"payload":{"lines":[60,61]},"content":"Cada una de sus capas tiene responsabilidades definidas y encapsula un conjunto de funcionalidades relacionadas."},{"type":"heading","depth":4,"payload":{"lines":[61,62]},"content":"Generalmente todas las capas mantienen la división general de: “cliente – lógica – almacenamiento”"}]},{"type":"heading","depth":3,"payload":{"lines":[62,63]},"content":"Cloud Computing","children":[{"type":"heading","depth":4,"payload":{"lines":[63,64]},"content":"Las aplicaciones del sistema se ejecutan en ambientes remotos, generalmente virtualizados y accesibles a través de Internet; de los cuales no se conoce previamente su ubicación."}]}]},{"type":"heading","depth":2,"payload":{"lines":[64,65]},"content":"Etapas de implemetación","children":[{"type":"heading","depth":3,"payload":{"lines":[65,66]},"content":"Análisis de requerimientos."},{"type":"heading","depth":3,"payload":{"lines":[66,67]},"content":"Automatización."},{"type":"heading","depth":3,"payload":{"lines":[67,68]},"content":"Armado del ambiente de pruebas."},{"type":"heading","depth":3,"payload":{"lines":[68,69]},"content":"Ejecución y reportes."}]},{"type":"heading","depth":2,"payload":{"lines":[70,71]},"content":"Perfiladores de muestreo","children":[{"type":"heading","depth":3,"payload":{"lines":[71,72]},"content":"Un generador de perfiles de muestreo sondea la pila de llamadas del programa de destino a intervalos regulares utilizando interrupciones del sistema operativo ."},{"type":"heading","depth":3,"payload":{"lines":[72,73]},"content":"Los perfiles de muestreo suelen ser menos precisos y específicos numéricamente, pero permiten que el programa de destino se ejecute casi a la máxima velocidad."},{"type":"heading","depth":3,"payload":{"lines":[73,74]},"content":"Pueden proporcionar una imagen más precisa de la ejecución del programa de destino que otros enfoques, ya que no son tan intrusivos para el programa de destino y, por lo tanto, no tienen tantos efectos secundarios"},{"type":"heading","depth":3,"payload":{"lines":[74,75]},"content":"Son relativamente inmunes a la sobrevaluación del costo de las rutinas pequeñas, comúnmente llamadas rutinas o ciclos &quot;ajustados&quot;"}]}]},{"type":"heading","depth":1,"payload":{"lines":[75,76]},"content":"Ejemplos de perfiladores en la industria","children":[{"type":"heading","depth":2,"payload":{"lines":[76,77]},"content":"SystemTap","children":[{"type":"heading","depth":3,"payload":{"lines":[77,78]},"content":"Herramienta de trazado y sondeos que permite a los usuarios monitorizar y analizar las actividades del sistema operativo (en particular las actividades de kernel)."},{"type":"heading","depth":3,"payload":{"lines":[78,79]},"content":"Proporciona un análisis preciso y profundo de las actividades del sistema y la conducta de aplicaciones para determinar los cuellos de botellas de las aplicaciones."}]},{"type":"heading","depth":2,"payload":{"lines":[79,80]},"content":"OProfile","children":[{"type":"heading","depth":3,"payload":{"lines":[80,81]},"content":"Herramienta de monitorización de rendimiento de todo el sistema."},{"type":"heading","depth":3,"payload":{"lines":[81,82]},"content":"Utiliza hardware dedicado de monitorización de rendimiento de procesos para recuperar información sobre el kernel y los ejecutables del sistema"},{"type":"heading","depth":3,"payload":{"lines":[82,83]},"content":"Las muestras de monitorización de rendimiento no pueden ser precisas, puesto que el procesador puede ejecutar instrucciones que no funcionan o registrar una muestra de una instrucción cercana, en lugar de la instrucción que produjo la interrupción."}]},{"type":"heading","depth":2,"payload":{"lines":[83,84]},"content":"Valgrind","children":[{"type":"heading","depth":3,"payload":{"lines":[84,85]},"content":"Ofrece herramientas que colaboran con el rendimiento y exactitud de nuestras aplicaciones. Estas herramientas pueden detectar errores de memoria y de hilos relacionados, y sobrecargas de montículo, pila y matrices, que le permiten localizar y corregir fácilmente errores en su código de aplicación."},{"type":"heading","depth":3,"payload":{"lines":[85,86]},"content":"Pueden también perfilar la memoria cache, el montículo y predicción de saltos para identificar los factores que incrementan la velocidad de aplicaciones y minimizan el uso de memoria de aplicaciones."},{"type":"heading","depth":3,"payload":{"lines":[86,87]},"content":"Analiza su aplicación al ejecutarla en una CPU sintética e instrumentando el código de aplicación existente mientras se ejecuta. El nivel de instrumentación varía según la herramienta Valgrind en uso y sus parámetros, pero es importante observar que al ejecutar el código instrumentado puede tardar de 4 a 50 veces más que la ejecución normal."}]}]}]},{})</script>
</body>
</html>
